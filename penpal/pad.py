import os
from hashlib import sha3_256
from math import ceil
from pathlib import Path
from secrets import choice

from penpal.hazmat.hazmat import get_random_bytes
from penpal.settings import MAX_BLOCK_SIZE, STD_BLOCK_SIZE
from penpal.utils.file_helpers import assert_secure_dir


def create_one_time_pad(path: Path, size: int):
    """Creates a pad at `path`.

    Note that `path`'s parent folder should already exist
    and have permissions set to 0o700.

    Arguments:
    path -- path to a new one-time pad
    size -- desired size of pad; resulting pad will be at least this large
    """
    if not path.parent.exists():
        error_msg = (f"Cannot create one-time pad at {path}; " +
                     "parent directory does not exist")
        raise ValueError(error_msg)
    if path.exists():
        error_msg = (f"Cannot create one-time pad at {path}; " +
                     "file or directory already present at location")
        raise ValueError(error_msg)
    assert_secure_dir(path.parent)

    # create new directory
    os.mkdir(path, 0o700)

    num_blocks = ceil(size / STD_BLOCK_SIZE)

    for _ in range(num_blocks):
        create_block_file(path, STD_BLOCK_SIZE)


def create_block_file(path: Path, size: int):
    """Creates a block file suitable for use as a one-time pad.
    The block file's data will be generated by the operating system's
    pseudorandom number generator via `os.urandom`.

    Note that `path`'s folder should already exist
    and have permissions set to 0o700.

    Arguments:
    path -- `Path` object that references an existing directory
            where block file should be created (e.g. /home/alice/pads/my.pad/blocks)
    size -- size of block file in bytes (must be less than `MAX_BLOCK_SIZE`)
    """
    assert_secure_dir(path)

    if size > MAX_BLOCK_SIZE:
        raise ValueError((f"Cannot create blocks larger than {MAX_BLOCK_SIZE} bytes. " +
                          f"Received request for {size} bytes."))

    data = get_random_bytes(size)

    # use sha3-256 digest of block for filename
    sha = sha3_256(data, usedforsecurity=True).hexdigest()
    block_file = path.joinpath(sha)

    # create block file
    with open(block_file, "wb") as f:
        f.write(data)

    os.chmod(block_file, 0o400)

    return sha


def fetch_and_destroy_random_block(pad_path: Path) -> (str, bytes):
    """Randomly selects a block from pad located at `pad_path`,
    collects the bytes from the block, notes the block's filename,
    and destroys the block file. Returns the name of the block file and
    the bytes from the block file.

    Arguments:
    `pad_path` -- path to the one-time pad
    """
    block_name = choice(os.listdir(pad_path))
    block_path = pad_path.joinpath(block_name)

    block_bytes = None
    with open(block_path, "rb") as block:
        block_bytes = block.read()

    os.remove(block_path)
    return (block_name, block_bytes)
